<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="utf-8">
	<title>Assignment 2</title>
	<script type="text/javascript" src="./d3.js"></script>
	<link rel="stylesheet" href="styles.css">
	<link href="https://fonts.googleapis.com/css?family=Roboto" rel="stylesheet">
	<link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
</head>

<body>
	<div id="container" class="container">
		<div class="card">
			<h2>Part1</h2>
		</div>
		<div class="card">
			<h2>Part2</h2>
			<div id="chart" class="chartDiv"></div>
			<div id="button" class="buttonDiv"></div>
			<div id="map"></div>
			<script type="text/javascript">

				//Global height
				var h = 400;
				var h_chart = 200;
				var padding = 30;

				var setupMap = function () {
					//Create SVG element
					var mapDiv = document.getElementById("map");
					var svg_map = d3.select(mapDiv).append("svg");
					var w_map = mapDiv.clientWidth;
					svg_map.attr("width", w_map).attr("height", h);

					// Define map projection
					var projection = d3.geoMercator()
						.scale(30000)
						.center([-73.9, 40.7])
						.translate([w_map / 2, h / 2]);

					// Define path generator
					var path = d3.geoPath()
						.projection(projection);

					//Define quantize scale to sort data values into buckets of color
					var color = d3.scaleQuantize()
						.domain([0, 4])
						.range(["rgb(237,248,233)", "rgb(186,228,179)", "rgb(116,196,118)", "rgb(49,163,84)", "rgb(0,109,44)"]);
					//Colors taken from colorbrewer.js, included in the D3 download

					return { projection, path, color, svg_map, w_map }
				}

				var setupButton = function (gBrush, brush, xScale) {
					//Create SVG element
					var buttonDiv = document.getElementById("button");
					var button = d3.select(buttonDiv).append("button").text("Animate!");

					button.on("click", animate)

					// for the first call, starDate is undefined, let's give a default value to it
					function animate(startDate = new Date('2006-01-01')) {
						// stop iteration if
						if (startDate > new Date('2016-01-01')) {
							return;
						}
						var endDate = new Date(startDate.getFullYear(), 11, 31)	

						// modify selected area programmatically 				
						gBrush.call(brush.move, [startDate, endDate].map(xScale));

						// do next iteration
						var nextDate = new Date(startDate.getFullYear() + 1, 0, 1)
						setTimeout(function(){ animate(nextDate); }, 1000);
					};
				}

				var setupChart = function () {
					//Create SVG element
					var chartDiv = document.getElementById("chart");
					var svg_chart = d3.select(chartDiv).append("svg");
					var w_chart = chartDiv.clientWidth;
					svg_chart.attr("width", w_chart).attr("height", h_chart);

					//For converting Dates to strings
					var formatTime = d3.timeFormat("%Y");

					//Function for converting CSV values from strings to Dates and numbers
					var rowConverter = function (d) {
						return {
							index: parseFloat(d.INDEX),
							date: new Date(d.RPT_DT),  //Make a new Date object
							lat: parseFloat(d.Latitude),  //Convert from string to float
							lon: parseFloat(d.Longitude)
						};
					}

					//Create scale functions, domain for y-scale will be set up later when the data is available
					var xScale = d3.scaleTime()
						.range([padding, w_chart - padding * 2])

					var yScale = d3.scaleLinear()
						.range([h_chart - padding, padding]);

					//Define X axis
					var xAxis = d3.axisBottom()
						.scale(xScale)
						.ticks(10)
						.tickFormat(formatTime);

					//Define Y axis
					var yAxis = d3.axisLeft()
						.scale(yScale)
						.ticks(10);

					//Create X axis
					svg_chart.append("g")
						.attr("class", "x axis")
						.attr("transform", "translate(0," + (h_chart - padding) + ")")
						.call(xAxis);

					//Create Y axis
					svg_chart.append("g")
						.attr("class", "y axis")
						.attr("transform", "translate(" + padding + ",0)")
						.call(yAxis);

					// now add titles to the axes
					svg_chart.append("text")
						.attr("text-anchor", "middle")  // this makes it easy to centre the text as the transform is applied to the anchor
						.attr("transform", "translate(" + (padding / 3) + "," + (h_chart / 2) + ")rotate(-90)")  // text is drawn off the screen top left, move down and out and rotate
						.text("# of murders");

					svg_chart.append("text")
						.attr("text-anchor", "middle")  // this makes it easy to centre the text as the transform is applied to the anchor
						.attr("transform", "translate(" + (w_chart / 2) + "," + (h_chart) + ")")  // centre below axis
						.text("Year");

					// now add titles to the graph
					svg_chart.append("text")
						.attr("text-anchor", "middle")  // this makes it easy to centre the text as the transform is applied to the anchor
						.attr("transform", "translate(" + (w_chart / 2) + "," + (padding / 2) + ")")  // text is drawn off the screen top left, move down and out and rotate
						.text("NYC Crimes");

					function drawChart(data) {
						//Calibrate the scale domain, given the max value in dataset
						xScale.domain([
							d3.min(data, function (d) { return new Date(d.key); }),
							d3.max(data, function (d) { return new Date(d.key); })
						]);

						yScale.domain([0, d3.max(data, function (d) { return d.values.length; })]);

						//Define line generator
						line = d3.line()
							.x(function (d) { return xScale(new Date(d.key)); })
							.y(function (d) { return yScale(d.values.length); });

						svg_chart.append("path")
							.datum(data)
							.attr("class", "line")
							.attr("d", line);

						//Update X axis
						svg_chart.select(".x.axis")
							.transition()
							.duration(500)
							.call(xAxis);

						//Update Y axis
						svg_chart.select(".y.axis")
							.transition()
							.duration(500)
							.call(yAxis);
					};

					return { xScale, rowConverter, svg_chart, drawChart }
				}

				var { projection, path, color, svg_map, w_map } = setupMap();
				var { xScale, rowConverter, svg_chart, drawChart } = setupChart();

				//Load in GeoJSON data
				d3.json("boroughs.geojson", function (json) {

					//Bind data and create one path per GeoJSON feature
					svg_map.selectAll("path")
						.data(json.features)
						.enter()
						.append("path")
						.attr("d", path)
						.style("fill", function (d) {
							return color(d.id);
						});

					//Create one label per state
					svg_map.selectAll("text")
						.data(json.features)
						.enter()
						.append("text")
						.attr("class", "label")
						.attr("x", function (d) {
							return path.centroid(d)[0];
						})
						.attr("y", function (d) {
							return path.centroid(d)[1];
						})
						.text(function (d) {
							if (d.properties.BoroName) {
								return d.properties.BoroName;
							};
						});

					d3.csv("all_murder.csv", rowConverter, function (data) {
						// sort datapoints according to date
						data.sort(function (a, b) {
							return new Date(b.date) - new Date(a.date);
						});

						// group them counting every murder a day 
						var convertedData = d3.nest()
							.key(function (d) { return d.date; })
							.entries(data);

						// draw the path chart from the sorted and grouped data
						drawChart(convertedData);

						// add circles to map
						var circles = svg_map
							.append("g")
							.selectAll("circle")
							.data(data)
							.enter()
							.append("circle")
							.attr("cx", function (d) {
								return projection([d.lon, d.lat])[0];
							})
							.attr("cy", function (d) {
								return projection([d.lon, d.lat])[1];
							})
							.attr("r", 3)
							.attr("class", "show");


						function onBrush() {
							if (d3.event.selection != null) {
								// revert circles to initial style
								circles.attr("class", "hidden");
								var brush_coords = d3.brushSelection(this);

								var startDate = xScale.invert(brush_coords[0])
								var endDate = xScale.invert(brush_coords[1])

								// style circles according to brushed area
								circles
									.filter(function (d) {
										var date = d.date
										var brushed = date > startDate && date < endDate;
										return brushed;
									})
									.attr("class", "show");
							}
						}

						var brush = d3.brushX()
							.extent([
								[padding, padding],
								[svg_chart.attr("width") - 2 * padding, svg_chart.attr("height") - padding]
							])
							.on("brush", onBrush);

						var gBrush = svg_chart.append("g")
							.call(brush);

						setupButton(gBrush, brush, xScale);							

					});

				});

			</script>
		</div>
	</div>
</body>

</html>